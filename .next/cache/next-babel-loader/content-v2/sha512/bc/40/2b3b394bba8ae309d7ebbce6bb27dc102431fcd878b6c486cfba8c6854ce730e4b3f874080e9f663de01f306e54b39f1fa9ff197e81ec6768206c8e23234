{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nObject.defineProperty(exports, \"Router\", {\n  enumerable: true,\n  get: function () {\n    return _router.default;\n  }\n});\nObject.defineProperty(exports, \"withRouter\", {\n  enumerable: true,\n  get: function () {\n    return _withRouter.default;\n  }\n});\nexports.useRouter = useRouter;\nexports.createRouter = createRouter;\nexports.makePublicRouterInstance = makePublicRouterInstance;\nexports.default = void 0;\n\nvar _react = _interopRequireDefault(require(\"react\"));\n\nvar _router = _interopRequireDefault(require(\"../shared/lib/router/router\"));\n\nvar _routerContext = require(\"../shared/lib/router-context\");\n\nvar _withRouter = _interopRequireDefault(require(\"./with-router\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nconst singletonRouter = {\n  router: null,\n  readyCallbacks: [],\n\n  ready(cb) {\n    if (this.router) return cb();\n\n    if (false) {\n      this.readyCallbacks.push(cb);\n    }\n  }\n\n}; // Create public properties and methods of the router in the singletonRouter\n\nconst urlPropertyFields = ['pathname', 'route', 'query', 'asPath', 'components', 'isFallback', 'basePath', 'locale', 'locales', 'defaultLocale', 'isReady', 'isPreview', 'isLocaleDomain', 'domainLocales'];\nconst routerEvents = ['routeChangeStart', 'beforeHistoryChange', 'routeChangeComplete', 'routeChangeError', 'hashChangeStart', 'hashChangeComplete'];\nconst coreMethodFields = ['push', 'replace', 'reload', 'back', 'prefetch', 'beforePopState']; // Events is a static property on the router, the router doesn't have to be initialized to use it\n\nObject.defineProperty(singletonRouter, 'events', {\n  get() {\n    return _router.default.events;\n  }\n\n});\nurlPropertyFields.forEach(field => {\n  // Here we need to use Object.defineProperty because we need to return\n  // the property assigned to the actual router\n  // The value might get changed as we change routes and this is the\n  // proper way to access it\n  Object.defineProperty(singletonRouter, field, {\n    get() {\n      const router = getRouter();\n      return router[field];\n    }\n\n  });\n});\ncoreMethodFields.forEach(field => {\n  singletonRouter[field] = (...args) => {\n    const router = getRouter();\n    return router[field](...args);\n  };\n});\nrouterEvents.forEach(event => {\n  singletonRouter.ready(() => {\n    _router.default.events.on(event, (...args) => {\n      const eventField = `on${event.charAt(0).toUpperCase()}${event.substring(1)}`;\n      const _singletonRouter = singletonRouter;\n\n      if (_singletonRouter[eventField]) {\n        try {\n          _singletonRouter[eventField](...args);\n        } catch (err) {\n          console.error(`Error when running the Router event: ${eventField}`);\n          console.error(`${err.message}\\n${err.stack}`);\n        }\n      }\n    });\n  });\n});\n\nfunction getRouter() {\n  if (!singletonRouter.router) {\n    const message = 'No router instance found.\\n' + 'You should only use \"next/router\" on the client side of your app.\\n';\n    throw new Error(message);\n  }\n\n  return singletonRouter.router;\n}\n\nvar _default = singletonRouter;\nexports.default = _default;\n\nfunction useRouter() {\n  return _react.default.useContext(_routerContext.RouterContext);\n}\n\nfunction createRouter(...args) {\n  singletonRouter.router = new _router.default(...args);\n  singletonRouter.readyCallbacks.forEach(cb => cb());\n  singletonRouter.readyCallbacks = [];\n  return singletonRouter.router;\n}\n\nfunction makePublicRouterInstance(router) {\n  const _router1 = router;\n  const instance = {};\n\n  for (const property of urlPropertyFields) {\n    if (typeof _router1[property] === 'object') {\n      instance[property] = Object.assign(Array.isArray(_router1[property]) ? [] : {}, _router1[property]) // makes sure query is not stateful\n      ;\n      continue;\n    }\n\n    instance[property] = _router1[property];\n  } // Events is a static property on the router, the router doesn't have to be initialized to use it\n\n\n  instance.events = _router.default.events;\n  coreMethodFields.forEach(field => {\n    instance[field] = (...args) => {\n      return _router1[field](...args);\n    };\n  });\n  return instance;\n}","map":{"version":3,"sources":["../../client/router.ts"],"names":[],"mappings":"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","sourcesContent":["/* global window */\nimport React from 'react'\nimport Router from '../shared/lib/router/router'\nimport type { NextRouter } from '../shared/lib/router/router'\nimport { RouterContext } from '../shared/lib/router-context'\n\ntype ClassArguments<T> = T extends new (...args: infer U) => any ? U : any\n\ntype RouterArgs = ClassArguments<typeof Router>\n\ntype SingletonRouterBase = {\n  router: Router | null\n  readyCallbacks: Array<() => any>\n  ready(cb: () => any): void\n}\n\nexport { Router }\n\nexport type { NextRouter }\n\nexport type SingletonRouter = SingletonRouterBase & NextRouter\n\nconst singletonRouter: SingletonRouterBase = {\n  router: null, // holds the actual router instance\n  readyCallbacks: [],\n  ready(cb: () => void) {\n    if (this.router) return cb()\n    if (typeof window !== 'undefined') {\n      this.readyCallbacks.push(cb)\n    }\n  },\n}\n\n// Create public properties and methods of the router in the singletonRouter\nconst urlPropertyFields = [\n  'pathname',\n  'route',\n  'query',\n  'asPath',\n  'components',\n  'isFallback',\n  'basePath',\n  'locale',\n  'locales',\n  'defaultLocale',\n  'isReady',\n  'isPreview',\n  'isLocaleDomain',\n  'domainLocales',\n]\nconst routerEvents = [\n  'routeChangeStart',\n  'beforeHistoryChange',\n  'routeChangeComplete',\n  'routeChangeError',\n  'hashChangeStart',\n  'hashChangeComplete',\n] as const\nexport type RouterEvent = typeof routerEvents[number]\n\nconst coreMethodFields = [\n  'push',\n  'replace',\n  'reload',\n  'back',\n  'prefetch',\n  'beforePopState',\n]\n\n// Events is a static property on the router, the router doesn't have to be initialized to use it\nObject.defineProperty(singletonRouter, 'events', {\n  get() {\n    return Router.events\n  },\n})\n\nurlPropertyFields.forEach((field: string) => {\n  // Here we need to use Object.defineProperty because we need to return\n  // the property assigned to the actual router\n  // The value might get changed as we change routes and this is the\n  // proper way to access it\n  Object.defineProperty(singletonRouter, field, {\n    get() {\n      const router = getRouter() as any\n      return router[field] as string\n    },\n  })\n})\n\ncoreMethodFields.forEach((field: string) => {\n  // We don't really know the types here, so we add them later instead\n  ;(singletonRouter as any)[field] = (...args: any[]) => {\n    const router = getRouter() as any\n    return router[field](...args)\n  }\n})\n\nrouterEvents.forEach((event) => {\n  singletonRouter.ready(() => {\n    Router.events.on(event, (...args) => {\n      const eventField = `on${event.charAt(0).toUpperCase()}${event.substring(\n        1\n      )}`\n      const _singletonRouter = singletonRouter as any\n      if (_singletonRouter[eventField]) {\n        try {\n          _singletonRouter[eventField](...args)\n        } catch (err) {\n          console.error(`Error when running the Router event: ${eventField}`)\n          console.error(`${err.message}\\n${err.stack}`)\n        }\n      }\n    })\n  })\n})\n\nfunction getRouter(): Router {\n  if (!singletonRouter.router) {\n    const message =\n      'No router instance found.\\n' +\n      'You should only use \"next/router\" on the client side of your app.\\n'\n    throw new Error(message)\n  }\n  return singletonRouter.router\n}\n\n// Export the singletonRouter and this is the public API.\nexport default singletonRouter as SingletonRouter\n\n// Reexport the withRoute HOC\nexport { default as withRouter } from './with-router'\n\nexport function useRouter(): NextRouter {\n  return React.useContext(RouterContext)\n}\n\n// INTERNAL APIS\n// -------------\n// (do not use following exports inside the app)\n\n// Create a router and assign it as the singleton instance.\n// This is used in client side when we are initilizing the app.\n// This should **not** be used inside the server.\nexport function createRouter(...args: RouterArgs): Router {\n  singletonRouter.router = new Router(...args)\n  singletonRouter.readyCallbacks.forEach((cb) => cb())\n  singletonRouter.readyCallbacks = []\n\n  return singletonRouter.router\n}\n\n// This function is used to create the `withRouter` router instance\nexport function makePublicRouterInstance(router: Router): NextRouter {\n  const _router = router as any\n  const instance = {} as any\n\n  for (const property of urlPropertyFields) {\n    if (typeof _router[property] === 'object') {\n      instance[property] = Object.assign(\n        Array.isArray(_router[property]) ? [] : {},\n        _router[property]\n      ) // makes sure query is not stateful\n      continue\n    }\n\n    instance[property] = _router[property]\n  }\n\n  // Events is a static property on the router, the router doesn't have to be initialized to use it\n  instance.events = Router.events\n\n  coreMethodFields.forEach((field) => {\n    instance[field] = (...args: any[]) => {\n      return _router[field](...args)\n    }\n  })\n\n  return instance\n}\n"]},"metadata":{},"sourceType":"script"}