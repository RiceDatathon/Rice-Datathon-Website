{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.markAssetError = markAssetError;\nexports.isAssetError = isAssetError;\nexports.getClientBuildManifest = getClientBuildManifest;\nexports.createRouteLoader = createRouteLoader;\n\nvar _getAssetPathFromRoute = _interopRequireDefault(require(\"../shared/lib/router/utils/get-asset-path-from-route\"));\n\nvar _requestIdleCallback = require(\"./request-idle-callback\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n} // 3.8s was arbitrarily chosen as it's what https://web.dev/interactive\n// considers as \"Good\" time-to-interactive. We must assume something went\n// wrong beyond this point, and then fall-back to a full page transition to\n// show the user something of value.\n\n\nvar MS_MAX_IDLE_DELAY = 3800;\n\nfunction withFuture(key, map, generator) {\n  var entry = map.get(key);\n\n  if (entry) {\n    if ('future' in entry) {\n      return entry.future;\n    }\n\n    return Promise.resolve(entry);\n  }\n\n  var resolver;\n  var prom = new Promise(function (resolve) {\n    resolver = resolve;\n  });\n  map.set(key, entry = {\n    resolve: resolver,\n    future: prom\n  });\n  return generator ? generator().then(function (value) {\n    return resolver(value), value;\n  }) : prom;\n}\n\nfunction hasPrefetch(link) {\n  try {\n    link = document.createElement('link');\n    return (// detect IE11 since it supports prefetch but isn't detected\n      // with relList.support\n      !!window.MSInputMethodContext && !!document.documentMode || link.relList.supports('prefetch')\n    );\n  } catch (e) {\n    return false;\n  }\n}\n\nvar canPrefetch = hasPrefetch();\n\nfunction prefetchViaDom(href, as, link) {\n  return new Promise(function (res, rej) {\n    if (document.querySelector(\"link[rel=\\\"prefetch\\\"][href^=\\\"\".concat(href, \"\\\"]\"))) {\n      return res();\n    }\n\n    link = document.createElement('link'); // The order of property assignment here is intentional:\n\n    if (as) link.as = as;\n    link.rel = \"prefetch\";\n    link.crossOrigin = process.env.__NEXT_CROSS_ORIGIN;\n    link.onload = res;\n    link.onerror = rej; // `href` should always be last:\n\n    link.href = href;\n    document.head.appendChild(link);\n  });\n}\n\nvar ASSET_LOAD_ERROR = Symbol('ASSET_LOAD_ERROR');\n\nfunction markAssetError(err) {\n  return Object.defineProperty(err, ASSET_LOAD_ERROR, {});\n}\n\nfunction isAssetError(err) {\n  return err && ASSET_LOAD_ERROR in err;\n}\n\nfunction appendScript(src, script) {\n  return new Promise(function (resolve, reject) {\n    script = document.createElement('script'); // The order of property assignment here is intentional.\n    // 1. Setup success/failure hooks in case the browser synchronously\n    //    executes when `src` is set.\n\n    script.onload = resolve;\n\n    script.onerror = function () {\n      return reject(markAssetError(new Error(\"Failed to load script: \".concat(src))));\n    }; // 2. Configure the cross-origin attribute before setting `src` in case the\n    //    browser begins to fetch.\n\n\n    script.crossOrigin = process.env.__NEXT_CROSS_ORIGIN; // 3. Finally, set the source and inject into the DOM in case the child\n    //    must be appended for fetching to start.\n\n    script.src = src;\n    document.body.appendChild(script);\n  });\n} // We wait for pages to be built in dev before we start the route transition\n// timeout to prevent an un-necessary hard navigation in development.\n\n\nvar devBuildPromise; // Resolve a promise that times out after given amount of milliseconds.\n\nfunction resolvePromiseWithTimeout(p, ms, err) {\n  return new Promise(function (resolve, reject) {\n    var cancelled = false;\n    p.then(function (r) {\n      // Resolved, cancel the timeout\n      cancelled = true;\n      resolve(r);\n    })[\"catch\"](reject); // We wrap these checks separately for better dead-code elimination in\n    // production bundles.\n\n    if (true) {\n      (devBuildPromise || Promise.resolve()).then(function () {\n        (0, _requestIdleCallback).requestIdleCallback(function () {\n          return setTimeout(function () {\n            if (!cancelled) {\n              reject(err);\n            }\n          }, ms);\n        });\n      });\n    }\n\n    if (false) {\n      (0, _requestIdleCallback).requestIdleCallback(function () {\n        return setTimeout(function () {\n          if (!cancelled) {\n            reject(err);\n          }\n        }, ms);\n      });\n    }\n  });\n}\n\nfunction getClientBuildManifest() {\n  if (self.__BUILD_MANIFEST) {\n    return Promise.resolve(self.__BUILD_MANIFEST);\n  }\n\n  var onBuildManifest = new Promise(function (resolve) {\n    // Mandatory because this is not concurrent safe:\n    var cb = self.__BUILD_MANIFEST_CB;\n\n    self.__BUILD_MANIFEST_CB = function () {\n      resolve(self.__BUILD_MANIFEST);\n      cb && cb();\n    };\n  });\n  return resolvePromiseWithTimeout(onBuildManifest, MS_MAX_IDLE_DELAY, markAssetError(new Error('Failed to load client build manifest')));\n}\n\nfunction getFilesForRoute(assetPrefix, route) {\n  if (true) {\n    return Promise.resolve({\n      scripts: [assetPrefix + '/_next/static/chunks/pages' + encodeURI((0, _getAssetPathFromRoute)[\"default\"](route, '.js'))],\n      // Styles are handled by `style-loader` in development:\n      css: []\n    });\n  }\n\n  return getClientBuildManifest().then(function (manifest) {\n    if (!(route in manifest)) {\n      throw markAssetError(new Error(\"Failed to lookup route: \".concat(route)));\n    }\n\n    var allFiles = manifest[route].map(function (entry) {\n      return assetPrefix + '/_next/' + encodeURI(entry);\n    });\n    return {\n      scripts: allFiles.filter(function (v) {\n        return v.endsWith('.js');\n      }),\n      css: allFiles.filter(function (v) {\n        return v.endsWith('.css');\n      })\n    };\n  });\n}\n\nfunction createRouteLoader(assetPrefix) {\n  var entrypoints = new Map();\n  var loadedScripts = new Map();\n  var styleSheets = new Map();\n  var routes = new Map();\n\n  function maybeExecuteScript(src) {\n    var prom = loadedScripts.get(src);\n\n    if (prom) {\n      return prom;\n    } // Skip executing script if it's already in the DOM:\n\n\n    if (document.querySelector(\"script[src^=\\\"\".concat(src, \"\\\"]\"))) {\n      return Promise.resolve();\n    }\n\n    loadedScripts.set(src, prom = appendScript(src));\n    return prom;\n  }\n\n  function fetchStyleSheet(href) {\n    var prom = styleSheets.get(href);\n\n    if (prom) {\n      return prom;\n    }\n\n    styleSheets.set(href, prom = fetch(href).then(function (res) {\n      if (!res.ok) {\n        throw new Error(\"Failed to load stylesheet: \".concat(href));\n      }\n\n      return res.text().then(function (text) {\n        return {\n          href: href,\n          content: text\n        };\n      });\n    })[\"catch\"](function (err) {\n      throw markAssetError(err);\n    }));\n    return prom;\n  }\n\n  return {\n    whenEntrypoint: function whenEntrypoint(route) {\n      return withFuture(route, entrypoints);\n    },\n    onEntrypoint: function onEntrypoint(route, execute) {\n      Promise.resolve(execute).then(function (fn) {\n        return fn();\n      }).then(function (exports) {\n        return {\n          component: exports && exports[\"default\"] || exports,\n          exports: exports\n        };\n      }, function (err) {\n        return {\n          error: err\n        };\n      }).then(function (input) {\n        var old = entrypoints.get(route);\n        entrypoints.set(route, input);\n        if (old && 'resolve' in old) old.resolve(input);\n      });\n    },\n    loadRoute: function loadRoute(route, prefetch) {\n      var _this = this;\n\n      return withFuture(route, routes, function () {\n        var routeFilesPromise = getFilesForRoute(assetPrefix, route).then(function (_ref) {\n          var scripts = _ref.scripts,\n              css = _ref.css;\n          return Promise.all([entrypoints.has(route) ? [] : Promise.all(scripts.map(maybeExecuteScript)), Promise.all(css.map(fetchStyleSheet))]);\n        }).then(function (res) {\n          return _this.whenEntrypoint(route).then(function (entrypoint) {\n            return {\n              entrypoint: entrypoint,\n              styles: res[1]\n            };\n          });\n        });\n\n        if (true) {\n          devBuildPromise = new Promise(function (resolve) {\n            if (routeFilesPromise) {\n              return routeFilesPromise[\"finally\"](function () {\n                resolve();\n              });\n            }\n          });\n        }\n\n        return resolvePromiseWithTimeout(routeFilesPromise, MS_MAX_IDLE_DELAY, markAssetError(new Error(\"Route did not complete loading: \".concat(route)))).then(function (_ref2) {\n          var entrypoint = _ref2.entrypoint,\n              styles = _ref2.styles;\n          var res = Object.assign({\n            styles: styles\n          }, entrypoint);\n          return 'error' in entrypoint ? entrypoint : res;\n        })[\"catch\"](function (err) {\n          if (prefetch) {\n            // we don't want to cache errors during prefetch\n            throw err;\n          }\n\n          return {\n            error: err\n          };\n        });\n      });\n    },\n    prefetch: function prefetch(route) {\n      var _this2 = this;\n\n      // https://github.com/GoogleChromeLabs/quicklink/blob/453a661fa1fa940e2d2e044452398e38c67a98fb/src/index.mjs#L115-L118\n      // License: Apache 2.0\n      var cn;\n\n      if (cn = navigator.connection) {\n        // Don't prefetch if using 2G or if Save-Data is enabled.\n        if (cn.saveData || /2g/.test(cn.effectiveType)) return Promise.resolve();\n      }\n\n      return getFilesForRoute(assetPrefix, route).then(function (output) {\n        return Promise.all(canPrefetch ? output.scripts.map(function (script) {\n          return prefetchViaDom(script, 'script');\n        }) : []);\n      }).then(function () {\n        (0, _requestIdleCallback).requestIdleCallback(function () {\n          return _this2.loadRoute(route, true)[\"catch\"](function () {});\n        });\n      })[\"catch\"]( // swallow prefetch errors\n      function () {});\n    }\n  };\n}","map":{"version":3,"sources":["../../client/route-loader.ts"],"names":[],"mappings":";;;;;QAsHgB,c,GAAA,c;QAIA,Y,GAAA,Y;QAgFA,sB,GAAA,sB;QAuDA,iB,GAAA,iB;;AA/PkB,IAAA,sBAAsD,GAAA,sBAAA,CAAA,OAAA,CAAA,sDAAA,CAAA,CAAtD;;AACE,IAAA,oBAAyB,GAAA,OAAA,CAAA,yBAAA,CAAzB;;;;;;EAEpC;AACA;AACA;AACA;;;AACA,IAAM,iBAAiB,GAAG,IAA1B;;SAmCS,U,CACP,G,EACA,G,EACA,S,EACY;AACZ,MAAI,KAAK,GAA8B,GAAG,CAAC,GAAJ,CAAQ,GAAR,CAAvC;;AACA,MAAI,KAAJ,EAAW;AACT,QAAE,YAAc,KAAhB,EAAuB;aACd,KAAK,CAAC,M;AACd;;WACM,OAAO,CAAC,OAAR,CAAgB,KAAhB,C;AACR;;AACD,MAAI,QAAJ;AACA,MAAM,IAAI,GAAe,IAAI,OAAJ,CAAW,UAAK,OAAL,EAAiB;AACnD,IAAA,QAAQ,GAAG,OAAX;AACD,GAFwB,CAAzB;AAGA,EAAA,GAAG,CAAC,GAAJ,CAAQ,GAAR,EAAc,KAAK,GAAA;AAAK,IAAA,OAAO,EAAE,QAAd;AAAyB,IAAA,MAAM,EAAE;AAAjC,GAAnB;SACO,SAAS,GAEZ,SAAS,GAAG,IAAZ,CAAgB,UAAE,KAAF;AAAA,WAAa,QAAQ,CAAC,KAAD,CAAR,EAAiB,KAA9B;AAAA,GAAhB,CAFY,GAGZ,I;AACL;;SASQ,W,CAAY,I,EAAiC;MAChD;AACF,IAAA,IAAI,GAAG,QAAQ,CAAC,aAAT,CAAsB,MAAtB,CAAP;WAEE;AACA;QACG,MAAM,CAAC,oB,IAAoB,CAAA,CAAO,QAAQ,CAAS,Y,IACtD,IAAI,CAAC,OAAL,CAAa,QAAb,CAAqB,UAArB;;AAEH,G,CAAA,OAAA,CAAA,EAAO;WACC,K;AACR;AACF;;AAED,IAAM,WAAW,GAAY,WAAW,EAAxC;;SAES,c,CACP,I,EACA,E,EACA,I,EACc;SACP,IAAI,OAAJ,CAAW,UAAQ,GAAR,EAAa,GAAb,EAAqB;AACrC,QAAI,QAAQ,CAAC,aAAT,0CAAsD,IAAtD,SAAJ,EAAqE;aAC5D,GAAG,E;AACX;;AAED,IAAA,IAAI,GAAG,QAAQ,CAAC,aAAT,CAAsB,MAAtB,CAAP,CALqC,CAOrC;;AACA,QAAI,EAAJ,EAAQ,IAAI,CAAE,EAAN,GAAW,EAAX;AACR,IAAA,IAAI,CAAE,GAAN;AACA,IAAA,IAAI,CAAE,WAAN,GAAoB,OAAO,CAAC,GAAR,CAAY,mBAAhC;AACA,IAAA,IAAI,CAAE,MAAN,GAAe,GAAf;AACA,IAAA,IAAI,CAAE,OAAN,GAAgB,GAAhB,CAZqC,CAcrC;;AACA,IAAA,IAAI,CAAE,IAAN,GAAa,IAAb;AAEA,IAAA,QAAQ,CAAC,IAAT,CAAc,WAAd,CAA0B,IAA1B;AACD,GAlBM,C;AAmBR;;AAED,IAAM,gBAAgB,GAAG,MAAM,CAAA,kBAAA,CAA/B;;SAEgB,c,CAAe,G,EAAmB;SACzC,MAAM,CAAC,cAAP,CAAsB,GAAtB,EAA2B,gBAA3B,EAA2C,EAA3C,C;AACR;;SAEe,Y,CAAa,G,EAAkC;SACtD,GAAG,IAAI,gBAAgB,IAAI,G;AACnC;;SAEQ,Y,CACP,G,EACA,M,EACkB;SACX,IAAI,OAAJ,CAAW,UAAE,OAAF,EAAW,MAAX,EAAsB;AACtC,IAAA,MAAM,GAAG,QAAQ,CAAC,aAAT,CAAsB,QAAtB,CAAT,CADsC,CAGtC;AACA;AACA;;AACA,IAAA,MAAM,CAAC,MAAP,GAAgB,OAAhB;;AACA,IAAA,MAAM,CAAC,OAAP,GAAc;AAAA,aACZ,MAAM,CAAC,cAAc,CAAC,IAAI,KAAJ,kCAAoC,GAApC,EAAD,CAAf,CADM;AAAA,KAAd,CAPsC,CAUtC;AACA;;;AACA,IAAA,MAAM,CAAC,WAAP,GAAqB,OAAO,CAAC,GAAR,CAAY,mBAAjC,CAZsC,CActC;AACA;;AACA,IAAA,MAAM,CAAC,GAAP,GAAa,GAAb;AACA,IAAA,QAAQ,CAAC,IAAT,CAAc,WAAd,CAA0B,MAA1B;AACD,GAlBM,C;AAmBR,C,CAED;AACA;;;AACA,IAAI,eAAJ,C,CAEA;;SACS,yB,CACP,C,EACA,E,EACA,G,EACY;SACL,IAAI,OAAJ,CAAW,UAAE,OAAF,EAAW,MAAX,EAAsB;AACtC,QAAI,SAAS,GAAG,KAAhB;AAEA,IAAA,CAAC,CAAC,IAAF,CAAM,UAAE,CAAF,EAAQ;AACZ;AACA,MAAA,SAAS,GAAG,IAAZ;AACA,MAAA,OAAO,CAAC,CAAD,CAAP;AACD,KAJD,WAIS,MAJT,EAHsC,CAStC;AACA;;AACA,cAA4C;OACxC,eAAe,IAAI,OAAO,CAAC,OAAR,E,EAAmB,I,CAAI,YAAO;YA1KrB,oB,EAAyB,mB,CAAA;AAAA,iBA4KnD,UAAU,CAAA,YAAO;AACf,gBAAE,CAAG,SAAL,EAAgB;AACd,cAAA,MAAM,CAAC,GAAD,CAAN;AACD;AACF,WAJS,EAIP,EAJO,CA5KyC;AAAA,S;AAkLtD,O;AACF;;AAED,eAA4C;UArLZ,oB,EAAyB,mB,CAAA;AAAA,eAuLrD,UAAU,CAAA,YAAO;AACf,cAAE,CAAG,SAAL,EAAgB;AACd,YAAA,MAAM,CAAC,GAAD,CAAN;AACD;AACF,SAJS,EAIP,EAJO,CAvL2C;AAAA,O;AA6LxD;AACF,GAhCM,C;AAiCR;;SAQe,sB,GAAuD;AACrE,MAAI,IAAI,CAAC,gBAAT,EAA2B;WAClB,OAAO,CAAC,OAAR,CAAgB,IAAI,CAAC,gBAArB,C;AACR;;AAED,MAAM,eAAe,GACnB,IAAI,OAAJ,CAAW,UAAuB,OAAvB,EAAmC;AAC5C;AACA,QAAM,EAAE,GAAG,IAAI,CAAC,mBAAhB;;AACA,IAAA,IAAI,CAAC,mBAAL,GAAwB,YAAS;AAC/B,MAAA,OAAO,CAAC,IAAI,CAAC,gBAAN,CAAP;AACA,MAAA,EAAE,IAAI,EAAE,EAAR;AACD,KAHD;AAID,GAPD,CADF;SAUO,yBAAyB,CAC9B,eAD8B,EAE9B,iBAF8B,EAG9B,cAAc,CAAC,IAAI,KAAJ,CAAS,sCAAT,CAAD,CAHgB,C;AAKjC;;SAMQ,gB,CACP,W,EACA,K,EACqB;AACrB,YAA4C;WACnC,OAAO,CAAC,OAAR,CAAe;AACpB,MAAA,OAAO,EAAA,CACL,WAAW,GAAA,4BAAX,GAEE,SAAS,CAAA,CAAA,GA3Oe,sBA2Of,aAAuB,KAAvB,EAA4B,KAA5B,CAAA,CAHN,CADa;AAMpB;AACA,MAAA,GAAG,EAAA;AAPiB,KAAf,C;AASR;;SACM,sBAAsB,GAAG,IAAzB,CAA6B,UAAE,QAAF,EAAe;AACjD,QAAE,EAAI,KAAK,IAAI,QAAb,CAAF,EAA0B;AACxB,YAAM,cAAc,CAAC,IAAI,KAAJ,mCAAqC,KAArC,EAAD,CAApB;AACD;;AACD,QAAM,QAAQ,GAAG,QAAQ,CAAC,KAAD,CAAR,CAAgB,GAAhB,CAAmB,UACjC,KADiC;AAAA,aACvB,WAAW,GAAA,SAAX,GAA0B,SAAS,CAAC,KAAD,CADZ;AAAA,KAAnB,CAAjB;;AAIE,MAAA,OAAO,EAAE,QAAQ,CAAC,MAAT,CAAe,UAAE,CAAF;AAAA,eAAQ,CAAC,CAAC,QAAF,CAAU,KAAV,CAAR;AAAA,OAAf,C;AACT,MAAA,GAAG,EAAE,QAAQ,CAAC,MAAT,CAAe,UAAE,CAAF;AAAA,eAAQ,CAAC,CAAC,QAAF,CAAU,MAAV,CAAR;AAAA,OAAf;;AAER,GAXM,C;AAYR;;SAEe,iB,CAAkB,W,EAAkC;AAClE,MAAM,WAAW,GACf,IAAI,GAAJ,EADF;AAEA,MAAM,aAAa,GAAkC,IAAI,GAAJ,EAArD;AACA,MAAM,WAAW,GAA0C,IAAI,GAAJ,EAA3D;AACA,MAAM,MAAM,GACV,IAAI,GAAJ,EADF;;WAGS,kB,CAAmB,G,EAA+B;AACzD,QAAI,IAAI,GAAiC,aAAa,CAAC,GAAd,CAAkB,GAAlB,CAAzC;;AACA,QAAI,IAAJ,EAAU;aACD,I;AACR,KAJwD,CAMzD;;;AACA,QAAI,QAAQ,CAAC,aAAT,yBAAuC,GAAvC,SAAJ,EAAqD;aAC5C,OAAO,CAAC,OAAR,E;AACR;;AAED,IAAA,aAAa,CAAC,GAAd,CAAkB,GAAlB,EAAwB,IAAI,GAAG,YAAY,CAAC,GAAD,CAA3C;WACO,I;AACR;;WAEQ,e,CAAgB,I,EAAwC;AAC/D,QAAI,IAAI,GAAyC,WAAW,CAAC,GAAZ,CAAgB,IAAhB,CAAjD;;AACA,QAAI,IAAJ,EAAU;aACD,I;AACR;;AAED,IAAA,WAAW,CAAC,GAAZ,CACE,IADF,EAEG,IAAI,GAAG,KAAK,CAAC,IAAD,CAAL,CACL,IADK,CACD,UAAE,GAAF,EAAU;AACb,UAAE,CAAG,GAAG,CAAC,EAAT,EAAa;AACX,cAAM,IAAI,KAAJ,sCAAwC,IAAxC,EAAN;AACD;;aACM,GAAG,CAAC,IAAJ,GAAW,IAAX,CAAe,UAAE,IAAF;AAAA,eAAM;AAAQ,UAAA,IAAI,EAAE,IAAd;AAAoB,UAAA,OAAO,EAAE;AAA7B,SAAN;AAAA,OAAf,C;AACR,KANK,WAOA,UAAE,GAAF,EAAU;AACd,YAAM,cAAc,CAAC,GAAD,CAApB;AACD,KATK,CAFV;WAaO,I;AACR;;;AAGC,IAAA,c,0BAAe,K,EAAe;aACrB,UAAU,CAAC,KAAD,EAAQ,WAAR,C;AAClB,K;AACD,IAAA,Y,wBAAa,K,EAAe,O,EAAwB;AAClD,MAAA,OAAO,CAAC,OAAR,CAAgB,OAAhB,EACG,IADH,CACO,UAAE,EAAF;AAAA,eAAS,EAAE,EAAX;AAAA,OADP,EAEG,IAFH,CAEO,UACF,OADE;AAAA,eACU;AACX,UAAA,SAAS,EAAG,OAAO,IAAI,OAAO,WAAlB,IAA+B,OADhC;AAEX,UAAA,OAAO,EAAE;AAFE,SADV;AAAA,OAFP,E,UAOK,G;eAAG;AAAQ,UAAA,KAAK,EAAE;AAAf,S;OAPR,EASG,IATH,CASO,UAAE,KAAF,EAA6B;AAChC,YAAM,GAAG,GAAG,WAAW,CAAC,GAAZ,CAAgB,KAAhB,CAAZ;AACA,QAAA,WAAW,CAAC,GAAZ,CAAgB,KAAhB,EAAuB,KAAvB;AACA,YAAI,GAAG,IAAA,aAAiB,GAAxB,EAA6B,GAAG,CAAC,OAAJ,CAAY,KAAZ;AAC9B,OAbH;AAcD,K;AACD,IAAA,S,qBAAU,K,EAAe,Q,EAAoB;AAAA;;aACpC,UAAU,CAAmB,KAAnB,EAA0B,MAA1B,EAAgC,YAAQ;AACvD,YAAM,iBAAiB,GAAG,gBAAgB,CAAC,WAAD,EAAc,KAAd,CAAhB,CACvB,IADuB,CACnB,gBAAuB;AAAA,cAAnB,OAAmB,QAAnB,OAAmB;AAAA,cAAV,GAAU,QAAV,GAAU;iBACnB,OAAO,CAAC,GAAR,CAAW,CAChB,WAAW,CAAC,GAAZ,CAAgB,KAAhB,IAAqB,EAArB,GAEI,OAAO,CAAC,GAAR,CAAY,OAAO,CAAC,GAAR,CAAY,kBAAZ,CAAZ,CAHY,EAIhB,OAAO,CAAC,GAAR,CAAY,GAAG,CAAC,GAAJ,CAAQ,eAAR,CAAZ,CAJgB,CAAX,C;AAMR,SARuB,EASvB,IATuB,CASnB,UAAE,GAAF,EAAU;uBACD,c,CAAe,K,EAAO,I,CAAI,UAAE,UAAF;AAAA,mBAAY;AAChD,cAAA,UAAU,EAAV,UADgD;AAEhD,cAAA,MAAM,EAAE,GAAG,CAAC,CAAD;AAFqC,aAAZ;AAAA,W;AAIvC,SAduB,CAA1B;;AAgBA,kBAA4C;AAC1C,UAAA,eAAe,GAAG,IAAI,OAAJ,CAAW,UAAQ,OAAR,EAAoB;AAC/C,gBAAI,iBAAJ,EAAuB;qBACd,iBAAiB,WAAjB,CAAyB,YAAO;AACrC,gBAAA,OAAO;AACR,eAFM,C;AAGR;AACF,WANiB,CAAlB;AAOD;;eAEM,yBAAyB,CAC9B,iBAD8B,EAE9B,iBAF8B,EAG9B,cAAc,CAAC,IAAI,KAAJ,2CAA6C,KAA7C,EAAD,CAHgB,CAAzB,CAKJ,IALI,CAKA,iBAA6B;AAAA,cAAzB,UAAyB,SAAzB,UAAyB;AAAA,cAAb,MAAa,SAAb,MAAa;AAChC,cAAM,GAAG,GAAqB,MAAM,CAAC,MAAP,CAAa;AAGvC,YAAA,MAAM,EAAE;AAH+B,WAAb,EAGP,UAHO,CAA9B;iBAIO,WAAW,UAAX,GAAwB,UAAxB,GAAqC,G;AAC7C,SAXI,WAYC,UAAE,GAAF,EAAU;AACd,cAAI,QAAJ,EAAc;AACZ;AACA,kBAAM,GAAN;AACD;;;AACQ,YAAA,KAAK,EAAE;;AACjB,SAlBI,C;AAmBR,OA9CgB,C;AA+ClB,K;AACD,IAAA,Q,oBAAS,K,EAA8B;AAAA;;AACrC;AACA;AACA,UAAI,EAAJ;;AACA,UAAK,EAAE,GAAI,SAAS,CAAS,UAA7B,EAA0C;AACxC;AACA,YAAI,EAAE,CAAC,QAAH,IAAW,KAAS,IAAT,CAAc,EAAE,CAAC,aAAjB,CAAf,EAA6C,OAAU,OAAO,CAAC,OAAR,EAAV;AAC9C;;aACM,gBAAgB,CAAC,WAAD,EAAc,KAAd,CAAhB,CACJ,IADI,CACA,UAAE,MAAF;AAAA,eACH,OAAO,CAAC,GAAR,CACE,WAAW,GACP,MAAM,CAAC,OAAP,CAAe,GAAf,CAAkB,UAAE,MAAF;AAAA,iBAAa,cAAc,CAAC,MAAD,EAAO,QAAP,CAA3B;AAAA,SAAlB,CADO,G,EADb,CADG;AAAA,OADA,EAQJ,IARI,CAQA,YAAO;YAhYgB,oB,EAAyB,mB,CAAA;AAAA,iBAAA,MAAA,CAiYpB,SAjYoB,CAiYV,KAjYU,EAiYH,IAjYG,WAiYQ,YAAO,CAAE,CAjYjB,CAAA;AAAA,S;AAkYpD,OAVI,YAYH;kBACM,CAAE,CAbL,C;AAeR;;AAEJ","sourcesContent":["import { ComponentType } from 'react'\nimport { ClientBuildManifest } from '../build/webpack/plugins/build-manifest-plugin'\nimport getAssetPathFromRoute from '../shared/lib/router/utils/get-asset-path-from-route'\nimport { requestIdleCallback } from './request-idle-callback'\n\n// 3.8s was arbitrarily chosen as it's what https://web.dev/interactive\n// considers as \"Good\" time-to-interactive. We must assume something went\n// wrong beyond this point, and then fall-back to a full page transition to\n// show the user something of value.\nconst MS_MAX_IDLE_DELAY = 3800\n\ndeclare global {\n  interface Window {\n    __BUILD_MANIFEST?: ClientBuildManifest\n    __BUILD_MANIFEST_CB?: Function\n  }\n}\n\nexport interface LoadedEntrypointSuccess {\n  component: ComponentType\n  exports: any\n}\nexport interface LoadedEntrypointFailure {\n  error: unknown\n}\nexport type RouteEntrypoint = LoadedEntrypointSuccess | LoadedEntrypointFailure\n\nexport interface RouteStyleSheet {\n  href: string\n  content: string\n}\n\nexport interface LoadedRouteSuccess extends LoadedEntrypointSuccess {\n  styles: RouteStyleSheet[]\n}\nexport interface LoadedRouteFailure {\n  error: unknown\n}\nexport type RouteLoaderEntry = LoadedRouteSuccess | LoadedRouteFailure\n\nexport type Future<V> = {\n  resolve: (entrypoint: V) => void\n  future: Promise<V>\n}\nfunction withFuture<T>(\n  key: string,\n  map: Map<string, Future<T> | T>,\n  generator?: () => Promise<T>\n): Promise<T> {\n  let entry: Future<T> | T | undefined = map.get(key)\n  if (entry) {\n    if ('future' in entry) {\n      return entry.future\n    }\n    return Promise.resolve(entry)\n  }\n  let resolver: (entrypoint: T) => void\n  const prom: Promise<T> = new Promise<T>((resolve) => {\n    resolver = resolve\n  })\n  map.set(key, (entry = { resolve: resolver!, future: prom }))\n  return generator\n    ? // eslint-disable-next-line no-sequences\n      generator().then((value) => (resolver(value), value))\n    : prom\n}\n\nexport interface RouteLoader {\n  whenEntrypoint(route: string): Promise<RouteEntrypoint>\n  onEntrypoint(route: string, execute: () => unknown): void\n  loadRoute(route: string, prefetch?: boolean): Promise<RouteLoaderEntry>\n  prefetch(route: string): Promise<void>\n}\n\nfunction hasPrefetch(link?: HTMLLinkElement): boolean {\n  try {\n    link = document.createElement('link')\n    return (\n      // detect IE11 since it supports prefetch but isn't detected\n      // with relList.support\n      (!!window.MSInputMethodContext && !!(document as any).documentMode) ||\n      link.relList.supports('prefetch')\n    )\n  } catch {\n    return false\n  }\n}\n\nconst canPrefetch: boolean = hasPrefetch()\n\nfunction prefetchViaDom(\n  href: string,\n  as: string,\n  link?: HTMLLinkElement\n): Promise<any> {\n  return new Promise<void>((res, rej) => {\n    if (document.querySelector(`link[rel=\"prefetch\"][href^=\"${href}\"]`)) {\n      return res()\n    }\n\n    link = document.createElement('link')\n\n    // The order of property assignment here is intentional:\n    if (as) link!.as = as\n    link!.rel = `prefetch`\n    link!.crossOrigin = process.env.__NEXT_CROSS_ORIGIN!\n    link!.onload = res as any\n    link!.onerror = rej\n\n    // `href` should always be last:\n    link!.href = href\n\n    document.head.appendChild(link)\n  })\n}\n\nconst ASSET_LOAD_ERROR = Symbol('ASSET_LOAD_ERROR')\n// TODO: unexport\nexport function markAssetError(err: Error): Error {\n  return Object.defineProperty(err, ASSET_LOAD_ERROR, {})\n}\n\nexport function isAssetError(err?: Error): boolean | undefined {\n  return err && ASSET_LOAD_ERROR in err\n}\n\nfunction appendScript(\n  src: string,\n  script?: HTMLScriptElement\n): Promise<unknown> {\n  return new Promise((resolve, reject) => {\n    script = document.createElement('script')\n\n    // The order of property assignment here is intentional.\n    // 1. Setup success/failure hooks in case the browser synchronously\n    //    executes when `src` is set.\n    script.onload = resolve\n    script.onerror = () =>\n      reject(markAssetError(new Error(`Failed to load script: ${src}`)))\n\n    // 2. Configure the cross-origin attribute before setting `src` in case the\n    //    browser begins to fetch.\n    script.crossOrigin = process.env.__NEXT_CROSS_ORIGIN!\n\n    // 3. Finally, set the source and inject into the DOM in case the child\n    //    must be appended for fetching to start.\n    script.src = src\n    document.body.appendChild(script)\n  })\n}\n\n// We wait for pages to be built in dev before we start the route transition\n// timeout to prevent an un-necessary hard navigation in development.\nlet devBuildPromise: Promise<void> | undefined\n\n// Resolve a promise that times out after given amount of milliseconds.\nfunction resolvePromiseWithTimeout<T>(\n  p: Promise<T>,\n  ms: number,\n  err: Error\n): Promise<T> {\n  return new Promise((resolve, reject) => {\n    let cancelled = false\n\n    p.then((r) => {\n      // Resolved, cancel the timeout\n      cancelled = true\n      resolve(r)\n    }).catch(reject)\n\n    // We wrap these checks separately for better dead-code elimination in\n    // production bundles.\n    if (process.env.NODE_ENV === 'development') {\n      ;(devBuildPromise || Promise.resolve()).then(() => {\n        requestIdleCallback(() =>\n          setTimeout(() => {\n            if (!cancelled) {\n              reject(err)\n            }\n          }, ms)\n        )\n      })\n    }\n\n    if (process.env.NODE_ENV !== 'development') {\n      requestIdleCallback(() =>\n        setTimeout(() => {\n          if (!cancelled) {\n            reject(err)\n          }\n        }, ms)\n      )\n    }\n  })\n}\n\n// TODO: stop exporting or cache the failure\n// It'd be best to stop exporting this. It's an implementation detail. We're\n// only exporting it for backwards compatibility with the `page-loader`.\n// Only cache this response as a last resort if we cannot eliminate all other\n// code branches that use the Build Manifest Callback and push them through\n// the Route Loader interface.\nexport function getClientBuildManifest(): Promise<ClientBuildManifest> {\n  if (self.__BUILD_MANIFEST) {\n    return Promise.resolve(self.__BUILD_MANIFEST)\n  }\n\n  const onBuildManifest: Promise<ClientBuildManifest> =\n    new Promise<ClientBuildManifest>((resolve) => {\n      // Mandatory because this is not concurrent safe:\n      const cb = self.__BUILD_MANIFEST_CB\n      self.__BUILD_MANIFEST_CB = () => {\n        resolve(self.__BUILD_MANIFEST!)\n        cb && cb()\n      }\n    })\n\n  return resolvePromiseWithTimeout<ClientBuildManifest>(\n    onBuildManifest,\n    MS_MAX_IDLE_DELAY,\n    markAssetError(new Error('Failed to load client build manifest'))\n  )\n}\n\ninterface RouteFiles {\n  scripts: string[]\n  css: string[]\n}\nfunction getFilesForRoute(\n  assetPrefix: string,\n  route: string\n): Promise<RouteFiles> {\n  if (process.env.NODE_ENV === 'development') {\n    return Promise.resolve({\n      scripts: [\n        assetPrefix +\n          '/_next/static/chunks/pages' +\n          encodeURI(getAssetPathFromRoute(route, '.js')),\n      ],\n      // Styles are handled by `style-loader` in development:\n      css: [],\n    })\n  }\n  return getClientBuildManifest().then((manifest) => {\n    if (!(route in manifest)) {\n      throw markAssetError(new Error(`Failed to lookup route: ${route}`))\n    }\n    const allFiles = manifest[route].map(\n      (entry) => assetPrefix + '/_next/' + encodeURI(entry)\n    )\n    return {\n      scripts: allFiles.filter((v) => v.endsWith('.js')),\n      css: allFiles.filter((v) => v.endsWith('.css')),\n    }\n  })\n}\n\nexport function createRouteLoader(assetPrefix: string): RouteLoader {\n  const entrypoints: Map<string, Future<RouteEntrypoint> | RouteEntrypoint> =\n    new Map()\n  const loadedScripts: Map<string, Promise<unknown>> = new Map()\n  const styleSheets: Map<string, Promise<RouteStyleSheet>> = new Map()\n  const routes: Map<string, Future<RouteLoaderEntry> | RouteLoaderEntry> =\n    new Map()\n\n  function maybeExecuteScript(src: string): Promise<unknown> {\n    let prom: Promise<unknown> | undefined = loadedScripts.get(src)\n    if (prom) {\n      return prom\n    }\n\n    // Skip executing script if it's already in the DOM:\n    if (document.querySelector(`script[src^=\"${src}\"]`)) {\n      return Promise.resolve()\n    }\n\n    loadedScripts.set(src, (prom = appendScript(src)))\n    return prom\n  }\n\n  function fetchStyleSheet(href: string): Promise<RouteStyleSheet> {\n    let prom: Promise<RouteStyleSheet> | undefined = styleSheets.get(href)\n    if (prom) {\n      return prom\n    }\n\n    styleSheets.set(\n      href,\n      (prom = fetch(href)\n        .then((res) => {\n          if (!res.ok) {\n            throw new Error(`Failed to load stylesheet: ${href}`)\n          }\n          return res.text().then((text) => ({ href: href, content: text }))\n        })\n        .catch((err) => {\n          throw markAssetError(err)\n        }))\n    )\n    return prom\n  }\n\n  return {\n    whenEntrypoint(route: string) {\n      return withFuture(route, entrypoints)\n    },\n    onEntrypoint(route: string, execute: () => unknown) {\n      Promise.resolve(execute)\n        .then((fn) => fn())\n        .then(\n          (exports: any) => ({\n            component: (exports && exports.default) || exports,\n            exports: exports,\n          }),\n          (err) => ({ error: err })\n        )\n        .then((input: RouteEntrypoint) => {\n          const old = entrypoints.get(route)\n          entrypoints.set(route, input)\n          if (old && 'resolve' in old) old.resolve(input)\n        })\n    },\n    loadRoute(route: string, prefetch?: boolean) {\n      return withFuture<RouteLoaderEntry>(route, routes, () => {\n        const routeFilesPromise = getFilesForRoute(assetPrefix, route)\n          .then(({ scripts, css }) => {\n            return Promise.all([\n              entrypoints.has(route)\n                ? []\n                : Promise.all(scripts.map(maybeExecuteScript)),\n              Promise.all(css.map(fetchStyleSheet)),\n            ] as const)\n          })\n          .then((res) => {\n            return this.whenEntrypoint(route).then((entrypoint) => ({\n              entrypoint,\n              styles: res[1],\n            }))\n          })\n\n        if (process.env.NODE_ENV === 'development') {\n          devBuildPromise = new Promise<void>((resolve) => {\n            if (routeFilesPromise) {\n              return routeFilesPromise.finally(() => {\n                resolve()\n              })\n            }\n          })\n        }\n\n        return resolvePromiseWithTimeout(\n          routeFilesPromise,\n          MS_MAX_IDLE_DELAY,\n          markAssetError(new Error(`Route did not complete loading: ${route}`))\n        )\n          .then(({ entrypoint, styles }) => {\n            const res: RouteLoaderEntry = Object.assign<\n              { styles: RouteStyleSheet[] },\n              RouteEntrypoint\n            >({ styles: styles! }, entrypoint)\n            return 'error' in entrypoint ? entrypoint : res\n          })\n          .catch((err) => {\n            if (prefetch) {\n              // we don't want to cache errors during prefetch\n              throw err\n            }\n            return { error: err }\n          })\n      })\n    },\n    prefetch(route: string): Promise<void> {\n      // https://github.com/GoogleChromeLabs/quicklink/blob/453a661fa1fa940e2d2e044452398e38c67a98fb/src/index.mjs#L115-L118\n      // License: Apache 2.0\n      let cn\n      if ((cn = (navigator as any).connection)) {\n        // Don't prefetch if using 2G or if Save-Data is enabled.\n        if (cn.saveData || /2g/.test(cn.effectiveType)) return Promise.resolve()\n      }\n      return getFilesForRoute(assetPrefix, route)\n        .then((output) =>\n          Promise.all(\n            canPrefetch\n              ? output.scripts.map((script) => prefetchViaDom(script, 'script'))\n              : []\n          )\n        )\n        .then(() => {\n          requestIdleCallback(() => this.loadRoute(route, true).catch(() => {}))\n        })\n        .catch(\n          // swallow prefetch errors\n          () => {}\n        )\n    },\n  }\n}\n"]},"metadata":{},"sourceType":"script"}