{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getParametrizedRoute = getParametrizedRoute;\nexports.getRouteRegex = getRouteRegex; // this isn't importing the escape-string-regex module\n// to reduce bytes\n\nfunction escapeRegex(str) {\n  return str.replace(/[|\\\\{}()[\\]^$+*?.-]/g, '\\\\$&');\n}\n\nfunction parseParameter(param) {\n  var optional = param.startsWith('[') && param.endsWith(']');\n\n  if (optional) {\n    param = param.slice(1, -1);\n  }\n\n  var repeat = param.startsWith('...');\n\n  if (repeat) {\n    param = param.slice(3);\n  }\n\n  return {\n    key: param,\n    repeat: repeat,\n    optional: optional\n  };\n}\n\nfunction getParametrizedRoute(route) {\n  var segments = (route.replace(/\\/$/, '') || '/').slice(1).split('/');\n  var groups = {};\n  var groupIndex = 1;\n  var parameterizedRoute = segments.map(function (segment) {\n    if (segment.startsWith('[') && segment.endsWith(']')) {\n      var _parseParameter = parseParameter(segment.slice(1, -1)),\n          key = _parseParameter.key,\n          optional = _parseParameter.optional,\n          repeat = _parseParameter.repeat;\n\n      groups[key] = {\n        pos: groupIndex++,\n        repeat: repeat,\n        optional: optional\n      };\n      return repeat ? optional ? '(?:/(.+?))?' : '/(.+?)' : '/([^/]+?)';\n    } else {\n      return \"/\".concat(escapeRegex(segment));\n    }\n  }).join(''); // dead code eliminate for browser since it's only needed\n  // while generating routes-manifest\n\n  if (false) {\n    var routeKeyCharCode = 97;\n    var routeKeyCharLength = 1; // builds a minimal routeKey using only a-z and minimal number of characters\n\n    var getSafeRouteKey = function getSafeRouteKey() {\n      var routeKey = '';\n\n      for (var i = 0; i < routeKeyCharLength; i++) {\n        routeKey += String.fromCharCode(routeKeyCharCode);\n        routeKeyCharCode++;\n\n        if (routeKeyCharCode > 122) {\n          routeKeyCharLength++;\n          routeKeyCharCode = 97;\n        }\n      }\n\n      return routeKey;\n    };\n\n    var routeKeys = {};\n    var namedParameterizedRoute = segments.map(function (segment) {\n      if (segment.startsWith('[') && segment.endsWith(']')) {\n        var _parseParameter2 = parseParameter(segment.slice(1, -1)),\n            key = _parseParameter2.key,\n            optional = _parseParameter2.optional,\n            repeat = _parseParameter2.repeat; // replace any non-word characters since they can break\n        // the named regex\n\n\n        var cleanedKey = key.replace(/\\W/g, '');\n        var invalidKey = false; // check if the key is still invalid and fallback to using a known\n        // safe key\n\n        if (cleanedKey.length === 0 || cleanedKey.length > 30) {\n          invalidKey = true;\n        }\n\n        if (!isNaN(parseInt(cleanedKey.substr(0, 1)))) {\n          invalidKey = true;\n        }\n\n        if (invalidKey) {\n          cleanedKey = getSafeRouteKey();\n        }\n\n        routeKeys[cleanedKey] = key;\n        return repeat ? optional ? \"(?:/(?<\".concat(cleanedKey, \">.+?))?\") : \"/(?<\".concat(cleanedKey, \">.+?)\") : \"/(?<\".concat(cleanedKey, \">[^/]+?)\");\n      } else {\n        return \"/\".concat(escapeRegex(segment));\n      }\n    }).join('');\n    return {\n      parameterizedRoute: parameterizedRoute,\n      namedParameterizedRoute: namedParameterizedRoute,\n      groups: groups,\n      routeKeys: routeKeys\n    };\n  }\n\n  return {\n    parameterizedRoute: parameterizedRoute,\n    groups: groups\n  };\n}\n\nfunction getRouteRegex(normalizedRoute) {\n  var result = getParametrizedRoute(normalizedRoute);\n\n  if ('routeKeys' in result) {\n    return {\n      re: new RegExp(\"^\".concat(result.parameterizedRoute, \"(?:/)?$\")),\n      groups: result.groups,\n      routeKeys: result.routeKeys,\n      namedRegex: \"^\".concat(result.namedParameterizedRoute, \"(?:/)?$\")\n    };\n  }\n\n  return {\n    re: new RegExp(\"^\".concat(result.parameterizedRoute, \"(?:/)?$\")),\n    groups: result.groups\n  };\n}","map":{"version":3,"sources":["../../../../../shared/lib/router/utils/route-regex.ts"],"names":[],"mappings":"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","sourcesContent":["interface Group {\n  pos: number\n  repeat: boolean\n  optional: boolean\n}\n\n// this isn't importing the escape-string-regex module\n// to reduce bytes\nfunction escapeRegex(str: string) {\n  return str.replace(/[|\\\\{}()[\\]^$+*?.-]/g, '\\\\$&')\n}\n\nfunction parseParameter(param: string) {\n  const optional = param.startsWith('[') && param.endsWith(']')\n  if (optional) {\n    param = param.slice(1, -1)\n  }\n  const repeat = param.startsWith('...')\n  if (repeat) {\n    param = param.slice(3)\n  }\n  return { key: param, repeat, optional }\n}\n\nexport function getParametrizedRoute(route: string) {\n  const segments = (route.replace(/\\/$/, '') || '/').slice(1).split('/')\n\n  const groups: { [groupName: string]: Group } = {}\n  let groupIndex = 1\n  const parameterizedRoute = segments\n    .map((segment) => {\n      if (segment.startsWith('[') && segment.endsWith(']')) {\n        const { key, optional, repeat } = parseParameter(segment.slice(1, -1))\n        groups[key] = { pos: groupIndex++, repeat, optional }\n        return repeat ? (optional ? '(?:/(.+?))?' : '/(.+?)') : '/([^/]+?)'\n      } else {\n        return `/${escapeRegex(segment)}`\n      }\n    })\n    .join('')\n\n  // dead code eliminate for browser since it's only needed\n  // while generating routes-manifest\n  if (typeof window === 'undefined') {\n    let routeKeyCharCode = 97\n    let routeKeyCharLength = 1\n\n    // builds a minimal routeKey using only a-z and minimal number of characters\n    const getSafeRouteKey = () => {\n      let routeKey = ''\n\n      for (let i = 0; i < routeKeyCharLength; i++) {\n        routeKey += String.fromCharCode(routeKeyCharCode)\n        routeKeyCharCode++\n\n        if (routeKeyCharCode > 122) {\n          routeKeyCharLength++\n          routeKeyCharCode = 97\n        }\n      }\n      return routeKey\n    }\n\n    const routeKeys: { [named: string]: string } = {}\n\n    let namedParameterizedRoute = segments\n      .map((segment) => {\n        if (segment.startsWith('[') && segment.endsWith(']')) {\n          const { key, optional, repeat } = parseParameter(segment.slice(1, -1))\n          // replace any non-word characters since they can break\n          // the named regex\n          let cleanedKey = key.replace(/\\W/g, '')\n          let invalidKey = false\n\n          // check if the key is still invalid and fallback to using a known\n          // safe key\n          if (cleanedKey.length === 0 || cleanedKey.length > 30) {\n            invalidKey = true\n          }\n          if (!isNaN(parseInt(cleanedKey.substr(0, 1)))) {\n            invalidKey = true\n          }\n\n          if (invalidKey) {\n            cleanedKey = getSafeRouteKey()\n          }\n\n          routeKeys[cleanedKey] = key\n          return repeat\n            ? optional\n              ? `(?:/(?<${cleanedKey}>.+?))?`\n              : `/(?<${cleanedKey}>.+?)`\n            : `/(?<${cleanedKey}>[^/]+?)`\n        } else {\n          return `/${escapeRegex(segment)}`\n        }\n      })\n      .join('')\n\n    return {\n      parameterizedRoute,\n      namedParameterizedRoute,\n      groups,\n      routeKeys,\n    }\n  }\n\n  return {\n    parameterizedRoute,\n    groups,\n  }\n}\n\nexport interface RouteRegex {\n  groups: { [groupName: string]: Group }\n  namedRegex?: string\n  re: RegExp\n  routeKeys?: { [named: string]: string }\n}\n\nexport function getRouteRegex(normalizedRoute: string): RouteRegex {\n  const result = getParametrizedRoute(normalizedRoute)\n  if ('routeKeys' in result) {\n    return {\n      re: new RegExp(`^${result.parameterizedRoute}(?:/)?$`),\n      groups: result.groups,\n      routeKeys: result.routeKeys,\n      namedRegex: `^${result.namedParameterizedRoute}(?:/)?$`,\n    }\n  }\n\n  return {\n    re: new RegExp(`^${result.parameterizedRoute}(?:/)?$`),\n    groups: result.groups,\n  }\n}\n"]},"metadata":{},"sourceType":"script"}