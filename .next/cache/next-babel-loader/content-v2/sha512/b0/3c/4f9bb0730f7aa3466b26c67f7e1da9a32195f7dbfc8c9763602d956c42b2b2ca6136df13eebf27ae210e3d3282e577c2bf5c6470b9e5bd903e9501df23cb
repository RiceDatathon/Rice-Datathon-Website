{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = initHeadManager;\nexports.DOMAttributeNames = void 0;\nconst DOMAttributeNames = {\n  acceptCharset: 'accept-charset',\n  className: 'class',\n  htmlFor: 'for',\n  httpEquiv: 'http-equiv',\n  noModule: 'noModule'\n};\nexports.DOMAttributeNames = DOMAttributeNames;\n\nfunction reactElementToDOM({\n  type,\n  props\n}) {\n  const el = document.createElement(type);\n\n  for (const p in props) {\n    if (!props.hasOwnProperty(p)) continue;\n    if (p === 'children' || p === 'dangerouslySetInnerHTML') continue; // we don't render undefined props to the DOM\n\n    if (props[p] === undefined) continue;\n    const attr = DOMAttributeNames[p] || p.toLowerCase();\n\n    if (type === 'script' && (attr === 'async' || attr === 'defer' || attr === 'noModule')) {\n      el[attr] = !!props[p];\n    } else {\n      el.setAttribute(attr, props[p]);\n    }\n  }\n\n  const {\n    children,\n    dangerouslySetInnerHTML\n  } = props;\n\n  if (dangerouslySetInnerHTML) {\n    el.innerHTML = dangerouslySetInnerHTML.__html || '';\n  } else if (children) {\n    el.textContent = typeof children === 'string' ? children : Array.isArray(children) ? children.join('') : '';\n  }\n\n  return el;\n}\n\nfunction updateElements(type, components) {\n  const headEl = document.getElementsByTagName('head')[0];\n  const headCountEl = headEl.querySelector('meta[name=next-head-count]');\n\n  if (true) {\n    if (!headCountEl) {\n      console.error('Warning: next-head-count is missing. https://nextjs.org/docs/messages/next-head-count-missing');\n      return;\n    }\n  }\n\n  const headCount = Number(headCountEl.content);\n  const oldTags = [];\n\n  for (let i = 0, j = headCountEl.previousElementSibling; i < headCount; i++, j = j.previousElementSibling) {\n    if (j.tagName.toLowerCase() === type) {\n      oldTags.push(j);\n    }\n  }\n\n  const newTags = components.map(reactElementToDOM).filter(newTag => {\n    for (let k = 0, len = oldTags.length; k < len; k++) {\n      const oldTag = oldTags[k];\n\n      if (oldTag.isEqualNode(newTag)) {\n        oldTags.splice(k, 1);\n        return false;\n      }\n    }\n\n    return true;\n  });\n  oldTags.forEach(t => t.parentNode.removeChild(t));\n  newTags.forEach(t => headEl.insertBefore(t, headCountEl));\n  headCountEl.content = (headCount - oldTags.length + newTags.length).toString();\n}\n\nfunction initHeadManager() {\n  let updatePromise = null;\n  return {\n    mountedInstances: new Set(),\n    updateHead: head => {\n      const promise = updatePromise = Promise.resolve().then(() => {\n        if (promise !== updatePromise) return;\n        updatePromise = null;\n        const tags = {};\n        head.forEach(h => {\n          if ( // If the font tag is loaded only on client navigation\n          // it won't be inlined. In this case revert to the original behavior\n          h.type === 'link' && h.props['data-optimized-fonts'] && !document.querySelector(`style[data-href=\"${h.props['data-href']}\"]`)) {\n            h.props.href = h.props['data-href'];\n            h.props['data-href'] = undefined;\n          }\n\n          const components = tags[h.type] || [];\n          components.push(h);\n          tags[h.type] = components;\n        });\n        const titleComponent = tags.title ? tags.title[0] : null;\n        let title = '';\n\n        if (titleComponent) {\n          const {\n            children\n          } = titleComponent.props;\n          title = typeof children === 'string' ? children : Array.isArray(children) ? children.join('') : '';\n        }\n\n        if (title !== document.title) document.title = title;\n        ['meta', 'base', 'link', 'style', 'script'].forEach(type => {\n          updateElements(type, tags[type] || []);\n        });\n      });\n    }\n  };\n}","map":{"version":3,"sources":["../../client/head-manager.ts"],"names":[],"mappings":"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","sourcesContent":["export const DOMAttributeNames: Record<string, string> = {\n  acceptCharset: 'accept-charset',\n  className: 'class',\n  htmlFor: 'for',\n  httpEquiv: 'http-equiv',\n  noModule: 'noModule',\n}\n\nfunction reactElementToDOM({ type, props }: JSX.Element): HTMLElement {\n  const el: HTMLElement = document.createElement(type)\n  for (const p in props) {\n    if (!props.hasOwnProperty(p)) continue\n    if (p === 'children' || p === 'dangerouslySetInnerHTML') continue\n\n    // we don't render undefined props to the DOM\n    if (props[p] === undefined) continue\n\n    const attr = DOMAttributeNames[p] || p.toLowerCase()\n    if (\n      type === 'script' &&\n      (attr === 'async' || attr === 'defer' || attr === 'noModule')\n    ) {\n      ;(el as HTMLScriptElement)[attr] = !!props[p]\n    } else {\n      el.setAttribute(attr, props[p])\n    }\n  }\n\n  const { children, dangerouslySetInnerHTML } = props\n  if (dangerouslySetInnerHTML) {\n    el.innerHTML = dangerouslySetInnerHTML.__html || ''\n  } else if (children) {\n    el.textContent =\n      typeof children === 'string'\n        ? children\n        : Array.isArray(children)\n        ? children.join('')\n        : ''\n  }\n  return el\n}\n\nfunction updateElements(type: string, components: JSX.Element[]): void {\n  const headEl = document.getElementsByTagName('head')[0]\n  const headCountEl: HTMLMetaElement = headEl.querySelector(\n    'meta[name=next-head-count]'\n  ) as HTMLMetaElement\n  if (process.env.NODE_ENV !== 'production') {\n    if (!headCountEl) {\n      console.error(\n        'Warning: next-head-count is missing. https://nextjs.org/docs/messages/next-head-count-missing'\n      )\n      return\n    }\n  }\n\n  const headCount = Number(headCountEl.content)\n  const oldTags: Element[] = []\n\n  for (\n    let i = 0, j = headCountEl.previousElementSibling;\n    i < headCount;\n    i++, j = j!.previousElementSibling\n  ) {\n    if (j!.tagName.toLowerCase() === type) {\n      oldTags.push(j!)\n    }\n  }\n  const newTags = (components.map(reactElementToDOM) as HTMLElement[]).filter(\n    (newTag) => {\n      for (let k = 0, len = oldTags.length; k < len; k++) {\n        const oldTag = oldTags[k]\n        if (oldTag.isEqualNode(newTag)) {\n          oldTags.splice(k, 1)\n          return false\n        }\n      }\n      return true\n    }\n  )\n\n  oldTags.forEach((t) => t.parentNode!.removeChild(t))\n  newTags.forEach((t) => headEl.insertBefore(t, headCountEl))\n  headCountEl.content = (headCount - oldTags.length + newTags.length).toString()\n}\n\nexport default function initHeadManager(): {\n  mountedInstances: Set<unknown>\n  updateHead: (head: JSX.Element[]) => void\n} {\n  let updatePromise: Promise<void> | null = null\n\n  return {\n    mountedInstances: new Set(),\n    updateHead: (head: JSX.Element[]) => {\n      const promise = (updatePromise = Promise.resolve().then(() => {\n        if (promise !== updatePromise) return\n\n        updatePromise = null\n        const tags: Record<string, JSX.Element[]> = {}\n\n        head.forEach((h) => {\n          if (\n            // If the font tag is loaded only on client navigation\n            // it won't be inlined. In this case revert to the original behavior\n            h.type === 'link' &&\n            h.props['data-optimized-fonts'] &&\n            !document.querySelector(\n              `style[data-href=\"${h.props['data-href']}\"]`\n            )\n          ) {\n            h.props.href = h.props['data-href']\n            h.props['data-href'] = undefined\n          }\n          const components = tags[h.type] || []\n          components.push(h)\n          tags[h.type] = components\n        })\n\n        const titleComponent = tags.title ? tags.title[0] : null\n        let title = ''\n        if (titleComponent) {\n          const { children } = titleComponent.props\n          title =\n            typeof children === 'string'\n              ? children\n              : Array.isArray(children)\n              ? children.join('')\n              : ''\n        }\n        if (title !== document.title) document.title = title\n        ;['meta', 'base', 'link', 'style', 'script'].forEach((type) => {\n          updateElements(type, tags[type] || [])\n        })\n      }))\n    },\n  }\n}\n"]},"metadata":{},"sourceType":"script"}