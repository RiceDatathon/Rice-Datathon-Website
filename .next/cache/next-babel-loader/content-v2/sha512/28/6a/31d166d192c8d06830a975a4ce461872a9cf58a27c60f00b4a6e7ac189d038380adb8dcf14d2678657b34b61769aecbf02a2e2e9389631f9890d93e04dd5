{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.useIntersection = useIntersection;\n\nvar _react = require(\"react\");\n\nvar _requestIdleCallback = require(\"./request-idle-callback\");\n\nconst hasIntersectionObserver = typeof IntersectionObserver !== 'undefined';\n\nfunction useIntersection({\n  rootMargin,\n  disabled\n}) {\n  const isDisabled = disabled || !hasIntersectionObserver;\n  const unobserve = (0, _react).useRef();\n  const [visible, setVisible] = (0, _react).useState(false);\n  const setRef = (0, _react).useCallback(el => {\n    if (unobserve.current) {\n      unobserve.current();\n      unobserve.current = undefined;\n    }\n\n    if (isDisabled || visible) return;\n\n    if (el && el.tagName) {\n      unobserve.current = observe(el, isVisible => isVisible && setVisible(isVisible), {\n        rootMargin\n      });\n    }\n  }, [isDisabled, rootMargin, visible]);\n  (0, _react).useEffect(() => {\n    if (!hasIntersectionObserver) {\n      if (!visible) {\n        const idleCallback = (0, _requestIdleCallback).requestIdleCallback(() => setVisible(true));\n        return () => (0, _requestIdleCallback).cancelIdleCallback(idleCallback);\n      }\n    }\n  }, [visible]);\n  return [setRef, visible];\n}\n\nfunction observe(element, callback, options) {\n  const {\n    id,\n    observer,\n    elements\n  } = createObserver(options);\n  elements.set(element, callback);\n  observer.observe(element);\n  return function unobserve() {\n    elements.delete(element);\n    observer.unobserve(element); // Destroy observer when there's nothing left to watch:\n\n    if (elements.size === 0) {\n      observer.disconnect();\n      observers.delete(id);\n    }\n  };\n}\n\nconst observers = new Map();\n\nfunction createObserver(options) {\n  const id = options.rootMargin || '';\n  let instance = observers.get(id);\n\n  if (instance) {\n    return instance;\n  }\n\n  const elements = new Map();\n  const observer = new IntersectionObserver(entries => {\n    entries.forEach(entry => {\n      const callback = elements.get(entry.target);\n      const isVisible = entry.isIntersecting || entry.intersectionRatio > 0;\n\n      if (callback && isVisible) {\n        callback(isVisible);\n      }\n    });\n  }, options);\n  observers.set(id, instance = {\n    id,\n    observer,\n    elements\n  });\n  return instance;\n}","map":{"version":3,"sources":["../../client/use-intersection.tsx"],"names":[],"mappings":"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","sourcesContent":["import { useCallback, useEffect, useRef, useState } from 'react'\nimport {\n  requestIdleCallback,\n  cancelIdleCallback,\n} from './request-idle-callback'\n\ntype UseIntersectionObserverInit = Pick<IntersectionObserverInit, 'rootMargin'>\ntype UseIntersection = { disabled?: boolean } & UseIntersectionObserverInit\ntype ObserveCallback = (isVisible: boolean) => void\ntype Observer = {\n  id: string\n  observer: IntersectionObserver\n  elements: Map<Element, ObserveCallback>\n}\n\nconst hasIntersectionObserver = typeof IntersectionObserver !== 'undefined'\n\nexport function useIntersection<T extends Element>({\n  rootMargin,\n  disabled,\n}: UseIntersection): [(element: T | null) => void, boolean] {\n  const isDisabled: boolean = disabled || !hasIntersectionObserver\n\n  const unobserve = useRef<Function>()\n  const [visible, setVisible] = useState(false)\n\n  const setRef = useCallback(\n    (el: T | null) => {\n      if (unobserve.current) {\n        unobserve.current()\n        unobserve.current = undefined\n      }\n\n      if (isDisabled || visible) return\n\n      if (el && el.tagName) {\n        unobserve.current = observe(\n          el,\n          (isVisible) => isVisible && setVisible(isVisible),\n          { rootMargin }\n        )\n      }\n    },\n    [isDisabled, rootMargin, visible]\n  )\n\n  useEffect(() => {\n    if (!hasIntersectionObserver) {\n      if (!visible) {\n        const idleCallback = requestIdleCallback(() => setVisible(true))\n        return () => cancelIdleCallback(idleCallback)\n      }\n    }\n  }, [visible])\n\n  return [setRef, visible]\n}\n\nfunction observe(\n  element: Element,\n  callback: ObserveCallback,\n  options: UseIntersectionObserverInit\n): () => void {\n  const { id, observer, elements } = createObserver(options)\n  elements.set(element, callback)\n\n  observer.observe(element)\n  return function unobserve(): void {\n    elements.delete(element)\n    observer.unobserve(element)\n\n    // Destroy observer when there's nothing left to watch:\n    if (elements.size === 0) {\n      observer.disconnect()\n      observers.delete(id)\n    }\n  }\n}\n\nconst observers = new Map<string, Observer>()\nfunction createObserver(options: UseIntersectionObserverInit): Observer {\n  const id = options.rootMargin || ''\n  let instance = observers.get(id)\n  if (instance) {\n    return instance\n  }\n\n  const elements = new Map<Element, ObserveCallback>()\n  const observer = new IntersectionObserver((entries) => {\n    entries.forEach((entry) => {\n      const callback = elements.get(entry.target)\n      const isVisible = entry.isIntersecting || entry.intersectionRatio > 0\n      if (callback && isVisible) {\n        callback(isVisible)\n      }\n    })\n  }, options)\n\n  observers.set(\n    id,\n    (instance = {\n      id,\n      observer,\n      elements,\n    })\n  )\n  return instance\n}\n"]},"metadata":{},"sourceType":"script"}